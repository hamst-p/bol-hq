"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@neodrag";
exports.ids = ["vendor-chunks/@neodrag"];
exports.modules = {

/***/ "(ssr)/./node_modules/@neodrag/react/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@neodrag/react/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDraggable: () => (/* binding */ useDraggable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n// ../core/dist/index.js\nvar DEFAULT_RECOMPUTE_BOUNDS = {\n  dragStart: true\n};\nvar draggable = (node, options = {}) => {\n  let {\n    bounds,\n    axis = \"both\",\n    gpuAcceleration = true,\n    legacyTranslate = true,\n    transform,\n    applyUserSelectHack = true,\n    disabled = false,\n    ignoreMultitouch = false,\n    recomputeBounds = DEFAULT_RECOMPUTE_BOUNDS,\n    grid,\n    position,\n    cancel,\n    handle,\n    defaultClass = \"neodrag\",\n    defaultClassDragging = \"neodrag-dragging\",\n    defaultClassDragged = \"neodrag-dragged\",\n    defaultPosition = { x: 0, y: 0 },\n    onDragStart,\n    onDrag,\n    onDragEnd\n  } = options;\n  let active = false;\n  let translateX = 0, translateY = 0;\n  let initialX = 0, initialY = 0;\n  let clientToNodeOffsetX = 0, clientToNodeOffsetY = 0;\n  let { x: xOffset, y: yOffset } = position ? { x: position?.x ?? 0, y: position?.y ?? 0 } : defaultPosition;\n  setTranslate(xOffset, yOffset);\n  let canMoveInX;\n  let canMoveInY;\n  let bodyOriginalUserSelectVal = \"\";\n  let computedBounds;\n  let nodeRect;\n  let dragEls;\n  let cancelEls;\n  let currentlyDraggedEl;\n  let isControlled = !!position;\n  recomputeBounds = { ...DEFAULT_RECOMPUTE_BOUNDS, ...recomputeBounds };\n  let activePointers = /* @__PURE__ */ new Set();\n  const bodyStyle = document.body.style;\n  const nodeClassList = node.classList;\n  function setTranslate(xPos = translateX, yPos = translateY) {\n    if (!transform) {\n      if (legacyTranslate) {\n        let common = `${+xPos}px, ${+yPos}px`;\n        return setStyle(\n          node,\n          \"transform\",\n          gpuAcceleration ? `translate3d(${common}, 0)` : `translate(${common})`\n        );\n      }\n      return setStyle(node, \"translate\", `${+xPos}px ${+yPos}px ${gpuAcceleration ? \"1px\" : \"\"}`);\n    }\n    const transformCalled = transform({ offsetX: xPos, offsetY: yPos, rootNode: node });\n    if (isString(transformCalled)) {\n      setStyle(node, \"transform\", transformCalled);\n    }\n  }\n  const getEventData = () => ({\n    offsetX: translateX,\n    offsetY: translateY,\n    rootNode: node,\n    currentNode: currentlyDraggedEl\n  });\n  const callEvent = (eventName, fn) => {\n    const data = getEventData();\n    node.dispatchEvent(new CustomEvent(eventName, { detail: data }));\n    fn?.(data);\n  };\n  function fireSvelteDragStartEvent() {\n    callEvent(\"neodrag:start\", onDragStart);\n  }\n  function fireSvelteDragEndEvent() {\n    callEvent(\"neodrag:end\", onDragEnd);\n  }\n  function fireSvelteDragEvent() {\n    callEvent(\"neodrag\", onDrag);\n  }\n  const listen = addEventListener;\n  listen(\"pointerdown\", dragStart, false);\n  listen(\"pointerup\", dragEnd, false);\n  listen(\"pointermove\", drag, false);\n  setStyle(node, \"touch-action\", \"none\");\n  const calculateInverseScale = () => {\n    let inverseScale = node.offsetWidth / nodeRect.width;\n    if (isNaN(inverseScale))\n      inverseScale = 1;\n    return inverseScale;\n  };\n  function dragStart(e) {\n    if (disabled)\n      return;\n    if (e.button === 2)\n      return;\n    activePointers.add(e.pointerId);\n    if (ignoreMultitouch && activePointers.size > 1)\n      return e.preventDefault();\n    if (recomputeBounds.dragStart)\n      computedBounds = computeBoundRect(bounds, node);\n    if (isString(handle) && isString(cancel) && handle === cancel)\n      throw new Error(\"`handle` selector can't be same as `cancel` selector\");\n    nodeClassList.add(defaultClass);\n    dragEls = getHandleEls(handle, node);\n    cancelEls = getCancelElements(cancel, node);\n    canMoveInX = /(both|x)/.test(axis);\n    canMoveInY = /(both|y)/.test(axis);\n    if (cancelElementContains(cancelEls, dragEls))\n      throw new Error(\n        \"Element being dragged can't be a child of the element on which `cancel` is applied\"\n      );\n    const eventTarget = e.composedPath()[0];\n    if (dragEls.some((el) => el.contains(eventTarget) || el.shadowRoot?.contains(eventTarget)) && !cancelElementContains(cancelEls, [eventTarget])) {\n      currentlyDraggedEl = dragEls.length === 1 ? node : dragEls.find((el) => el.contains(eventTarget));\n      active = true;\n    } else\n      return;\n    nodeRect = node.getBoundingClientRect();\n    if (applyUserSelectHack) {\n      bodyOriginalUserSelectVal = bodyStyle.userSelect;\n      bodyStyle.userSelect = \"none\";\n    }\n    fireSvelteDragStartEvent();\n    const { clientX, clientY } = e;\n    const inverseScale = calculateInverseScale();\n    if (canMoveInX)\n      initialX = clientX - xOffset / inverseScale;\n    if (canMoveInY)\n      initialY = clientY - yOffset / inverseScale;\n    if (computedBounds) {\n      clientToNodeOffsetX = clientX - nodeRect.left;\n      clientToNodeOffsetY = clientY - nodeRect.top;\n    }\n  }\n  function dragEnd(e) {\n    activePointers.delete(e.pointerId);\n    if (!active)\n      return;\n    if (recomputeBounds.dragEnd)\n      computedBounds = computeBoundRect(bounds, node);\n    nodeClassList.remove(defaultClassDragging);\n    nodeClassList.add(defaultClassDragged);\n    if (applyUserSelectHack)\n      bodyStyle.userSelect = bodyOriginalUserSelectVal;\n    fireSvelteDragEndEvent();\n    if (canMoveInX)\n      initialX = translateX;\n    if (canMoveInY)\n      initialY = translateY;\n    active = false;\n  }\n  function drag(e) {\n    if (!active || ignoreMultitouch && activePointers.size > 1)\n      return;\n    if (recomputeBounds.drag)\n      computedBounds = computeBoundRect(bounds, node);\n    nodeClassList.add(defaultClassDragging);\n    e.preventDefault();\n    nodeRect = node.getBoundingClientRect();\n    let finalX = e.clientX, finalY = e.clientY;\n    const inverseScale = calculateInverseScale();\n    if (computedBounds) {\n      const virtualClientBounds = {\n        left: computedBounds.left + clientToNodeOffsetX,\n        top: computedBounds.top + clientToNodeOffsetY,\n        right: computedBounds.right + clientToNodeOffsetX - nodeRect.width,\n        bottom: computedBounds.bottom + clientToNodeOffsetY - nodeRect.height\n      };\n      finalX = clamp(finalX, virtualClientBounds.left, virtualClientBounds.right);\n      finalY = clamp(finalY, virtualClientBounds.top, virtualClientBounds.bottom);\n    }\n    if (Array.isArray(grid)) {\n      let [xSnap, ySnap] = grid;\n      if (isNaN(+xSnap) || xSnap < 0)\n        throw new Error(\"1st argument of `grid` must be a valid positive number\");\n      if (isNaN(+ySnap) || ySnap < 0)\n        throw new Error(\"2nd argument of `grid` must be a valid positive number\");\n      let deltaX = finalX - initialX, deltaY = finalY - initialY;\n      [deltaX, deltaY] = snapToGrid([xSnap / inverseScale, ySnap / inverseScale], deltaX, deltaY);\n      finalX = initialX + deltaX;\n      finalY = initialY + deltaY;\n    }\n    if (canMoveInX)\n      translateX = Math.round((finalX - initialX) * inverseScale);\n    if (canMoveInY)\n      translateY = Math.round((finalY - initialY) * inverseScale);\n    xOffset = translateX;\n    yOffset = translateY;\n    fireSvelteDragEvent();\n    setTranslate();\n  }\n  return {\n    destroy: () => {\n      const unlisten = removeEventListener;\n      unlisten(\"pointerdown\", dragStart, false);\n      unlisten(\"pointerup\", dragEnd, false);\n      unlisten(\"pointermove\", drag, false);\n    },\n    update: (options2) => {\n      axis = options2.axis || \"both\";\n      disabled = options2.disabled ?? false;\n      ignoreMultitouch = options2.ignoreMultitouch ?? false;\n      handle = options2.handle;\n      bounds = options2.bounds;\n      recomputeBounds = options2.recomputeBounds ?? DEFAULT_RECOMPUTE_BOUNDS;\n      cancel = options2.cancel;\n      applyUserSelectHack = options2.applyUserSelectHack ?? true;\n      grid = options2.grid;\n      gpuAcceleration = options2.gpuAcceleration ?? true;\n      legacyTranslate = options2.legacyTranslate ?? true;\n      transform = options2.transform;\n      const dragged = nodeClassList.contains(defaultClassDragged);\n      nodeClassList.remove(defaultClass, defaultClassDragged);\n      defaultClass = options2.defaultClass ?? \"neodrag\";\n      defaultClassDragging = options2.defaultClassDragging ?? \"neodrag-dragging\";\n      defaultClassDragged = options2.defaultClassDragged ?? \"neodrag-dragged\";\n      nodeClassList.add(defaultClass);\n      if (dragged)\n        nodeClassList.add(defaultClassDragged);\n      if (isControlled) {\n        xOffset = translateX = options2.position?.x ?? translateX;\n        yOffset = translateY = options2.position?.y ?? translateY;\n        setTranslate();\n      }\n    }\n  };\n};\nvar clamp = (val, min, max) => Math.min(Math.max(val, min), max);\nvar isString = (val) => typeof val === \"string\";\nvar snapToGrid = ([xSnap, ySnap], pendingX, pendingY) => {\n  const calc = (val, snap) => snap === 0 ? 0 : Math.ceil(val / snap) * snap;\n  const x = calc(pendingX, xSnap);\n  const y = calc(pendingY, ySnap);\n  return [x, y];\n};\nfunction getHandleEls(handle, node) {\n  if (!handle)\n    return [node];\n  if (isHTMLElement(handle))\n    return [handle];\n  if (Array.isArray(handle))\n    return handle;\n  const handleEls = node.querySelectorAll(handle);\n  if (handleEls === null)\n    throw new Error(\n      \"Selector passed for `handle` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(handleEls.values());\n}\nfunction getCancelElements(cancel, node) {\n  if (!cancel)\n    return [];\n  if (isHTMLElement(cancel))\n    return [cancel];\n  if (Array.isArray(cancel))\n    return cancel;\n  const cancelEls = node.querySelectorAll(cancel);\n  if (cancelEls === null)\n    throw new Error(\n      \"Selector passed for `cancel` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(cancelEls.values());\n}\nvar cancelElementContains = (cancelElements, dragElements) => cancelElements.some((cancelEl) => dragElements.some((el) => cancelEl.contains(el)));\nfunction computeBoundRect(bounds, rootNode) {\n  if (bounds === void 0)\n    return;\n  if (isHTMLElement(bounds))\n    return bounds.getBoundingClientRect();\n  if (typeof bounds === \"object\") {\n    const { top = 0, left = 0, right = 0, bottom = 0 } = bounds;\n    const computedRight = window.innerWidth - right;\n    const computedBottom = window.innerHeight - bottom;\n    return { top, right: computedRight, bottom: computedBottom, left };\n  }\n  if (bounds === \"parent\")\n    return rootNode.parentNode.getBoundingClientRect();\n  const node = document.querySelector(bounds);\n  if (node === null)\n    throw new Error(\"The selector provided for bound doesn't exists in the document.\");\n  return node.getBoundingClientRect();\n}\nvar setStyle = (el, style, value) => el.style.setProperty(style, value);\nvar isHTMLElement = (obj) => obj instanceof HTMLElement;\nfunction unwrapHandleCancel(val) {\n  if (val == void 0 || typeof val === \"string\" || val instanceof HTMLElement)\n    return val;\n  if (\"current\" in val)\n    return val.current;\n  if (Array.isArray(val)) {\n    return val.map((v) => v instanceof HTMLElement ? v : v.current);\n  }\n}\nfunction useDraggable(nodeRef, options = {}) {\n  const updateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  const [isDragging, setIsDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [dragState, setDragState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  let { onDragStart, onDrag, onDragEnd, handle, cancel } = options;\n  let newHandle = unwrapHandleCancel(handle);\n  let newCancel = unwrapHandleCancel(cancel);\n  function callEvent(arg, cb) {\n    setDragState(arg);\n    cb?.(arg);\n  }\n  function customOnDragStart(arg) {\n    setIsDragging(true);\n    callEvent(arg, onDragStart);\n  }\n  function customOnDrag(arg) {\n    callEvent(arg, onDrag);\n  }\n  function customOnDragEnd(arg) {\n    setIsDragging(false);\n    callEvent(arg, onDragEnd);\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (typeof window === \"undefined\")\n      return;\n    const node = nodeRef.current;\n    if (!node)\n      return;\n    ({ onDragStart, onDrag, onDragEnd } = options);\n    const { update, destroy } = draggable(node, {\n      ...options,\n      handle: newHandle,\n      cancel: newCancel,\n      onDragStart: customOnDragStart,\n      onDrag: customOnDrag,\n      onDragEnd: customOnDragEnd\n    });\n    updateRef.current = update;\n    return destroy;\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    updateRef.current?.({\n      ...options,\n      handle: unwrapHandleCancel(handle),\n      cancel: unwrapHandleCancel(cancel),\n      onDragStart: customOnDragStart,\n      onDrag: customOnDrag,\n      onDragEnd: customOnDragEnd\n    });\n  }, [options]);\n  return { isDragging, dragState };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5lb2RyYWcvcmVhY3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUJBQXlCLGVBQWUsMkNBQTJDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNLE1BQU0sTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTyxxQkFBcUIsT0FBTztBQUM5RTtBQUNBO0FBQ0EsNENBQTRDLE1BQU0sS0FBSyxNQUFNLEtBQUssNkJBQTZCO0FBQy9GO0FBQ0Esd0NBQXdDLDhDQUE4QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUEyQztBQUN2RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLG9CQUFvQiw2Q0FBTTtBQUMxQixzQ0FBc0MsK0NBQVE7QUFDOUMsb0NBQW9DLCtDQUFRO0FBQzVDLFFBQVEsaURBQWlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8saUNBQWlDO0FBQ3hDLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsV0FBVztBQUNYOztBQUV3QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AbmVvZHJhZy9yZWFjdC9kaXN0L2luZGV4LmpzPzE3ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vLyAuLi9jb3JlL2Rpc3QvaW5kZXguanNcbnZhciBERUZBVUxUX1JFQ09NUFVURV9CT1VORFMgPSB7XG4gIGRyYWdTdGFydDogdHJ1ZVxufTtcbnZhciBkcmFnZ2FibGUgPSAobm9kZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGxldCB7XG4gICAgYm91bmRzLFxuICAgIGF4aXMgPSBcImJvdGhcIixcbiAgICBncHVBY2NlbGVyYXRpb24gPSB0cnVlLFxuICAgIGxlZ2FjeVRyYW5zbGF0ZSA9IHRydWUsXG4gICAgdHJhbnNmb3JtLFxuICAgIGFwcGx5VXNlclNlbGVjdEhhY2sgPSB0cnVlLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgaWdub3JlTXVsdGl0b3VjaCA9IGZhbHNlLFxuICAgIHJlY29tcHV0ZUJvdW5kcyA9IERFRkFVTFRfUkVDT01QVVRFX0JPVU5EUyxcbiAgICBncmlkLFxuICAgIHBvc2l0aW9uLFxuICAgIGNhbmNlbCxcbiAgICBoYW5kbGUsXG4gICAgZGVmYXVsdENsYXNzID0gXCJuZW9kcmFnXCIsXG4gICAgZGVmYXVsdENsYXNzRHJhZ2dpbmcgPSBcIm5lb2RyYWctZHJhZ2dpbmdcIixcbiAgICBkZWZhdWx0Q2xhc3NEcmFnZ2VkID0gXCJuZW9kcmFnLWRyYWdnZWRcIixcbiAgICBkZWZhdWx0UG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfSxcbiAgICBvbkRyYWdTdGFydCxcbiAgICBvbkRyYWcsXG4gICAgb25EcmFnRW5kXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgYWN0aXZlID0gZmFsc2U7XG4gIGxldCB0cmFuc2xhdGVYID0gMCwgdHJhbnNsYXRlWSA9IDA7XG4gIGxldCBpbml0aWFsWCA9IDAsIGluaXRpYWxZID0gMDtcbiAgbGV0IGNsaWVudFRvTm9kZU9mZnNldFggPSAwLCBjbGllbnRUb05vZGVPZmZzZXRZID0gMDtcbiAgbGV0IHsgeDogeE9mZnNldCwgeTogeU9mZnNldCB9ID0gcG9zaXRpb24gPyB7IHg6IHBvc2l0aW9uPy54ID8/IDAsIHk6IHBvc2l0aW9uPy55ID8/IDAgfSA6IGRlZmF1bHRQb3NpdGlvbjtcbiAgc2V0VHJhbnNsYXRlKHhPZmZzZXQsIHlPZmZzZXQpO1xuICBsZXQgY2FuTW92ZUluWDtcbiAgbGV0IGNhbk1vdmVJblk7XG4gIGxldCBib2R5T3JpZ2luYWxVc2VyU2VsZWN0VmFsID0gXCJcIjtcbiAgbGV0IGNvbXB1dGVkQm91bmRzO1xuICBsZXQgbm9kZVJlY3Q7XG4gIGxldCBkcmFnRWxzO1xuICBsZXQgY2FuY2VsRWxzO1xuICBsZXQgY3VycmVudGx5RHJhZ2dlZEVsO1xuICBsZXQgaXNDb250cm9sbGVkID0gISFwb3NpdGlvbjtcbiAgcmVjb21wdXRlQm91bmRzID0geyAuLi5ERUZBVUxUX1JFQ09NUFVURV9CT1VORFMsIC4uLnJlY29tcHV0ZUJvdW5kcyB9O1xuICBsZXQgYWN0aXZlUG9pbnRlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBib2R5U3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICBjb25zdCBub2RlQ2xhc3NMaXN0ID0gbm9kZS5jbGFzc0xpc3Q7XG4gIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZSh4UG9zID0gdHJhbnNsYXRlWCwgeVBvcyA9IHRyYW5zbGF0ZVkpIHtcbiAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgaWYgKGxlZ2FjeVRyYW5zbGF0ZSkge1xuICAgICAgICBsZXQgY29tbW9uID0gYCR7K3hQb3N9cHgsICR7K3lQb3N9cHhgO1xuICAgICAgICByZXR1cm4gc2V0U3R5bGUoXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgIGdwdUFjY2VsZXJhdGlvbiA/IGB0cmFuc2xhdGUzZCgke2NvbW1vbn0sIDApYCA6IGB0cmFuc2xhdGUoJHtjb21tb259KWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRTdHlsZShub2RlLCBcInRyYW5zbGF0ZVwiLCBgJHsreFBvc31weCAkeyt5UG9zfXB4ICR7Z3B1QWNjZWxlcmF0aW9uID8gXCIxcHhcIiA6IFwiXCJ9YCk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybUNhbGxlZCA9IHRyYW5zZm9ybSh7IG9mZnNldFg6IHhQb3MsIG9mZnNldFk6IHlQb3MsIHJvb3ROb2RlOiBub2RlIH0pO1xuICAgIGlmIChpc1N0cmluZyh0cmFuc2Zvcm1DYWxsZWQpKSB7XG4gICAgICBzZXRTdHlsZShub2RlLCBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm1DYWxsZWQpO1xuICAgIH1cbiAgfVxuICBjb25zdCBnZXRFdmVudERhdGEgPSAoKSA9PiAoe1xuICAgIG9mZnNldFg6IHRyYW5zbGF0ZVgsXG4gICAgb2Zmc2V0WTogdHJhbnNsYXRlWSxcbiAgICByb290Tm9kZTogbm9kZSxcbiAgICBjdXJyZW50Tm9kZTogY3VycmVudGx5RHJhZ2dlZEVsXG4gIH0pO1xuICBjb25zdCBjYWxsRXZlbnQgPSAoZXZlbnROYW1lLCBmbikgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRFdmVudERhdGEoKTtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWw6IGRhdGEgfSkpO1xuICAgIGZuPy4oZGF0YSk7XG4gIH07XG4gIGZ1bmN0aW9uIGZpcmVTdmVsdGVEcmFnU3RhcnRFdmVudCgpIHtcbiAgICBjYWxsRXZlbnQoXCJuZW9kcmFnOnN0YXJ0XCIsIG9uRHJhZ1N0YXJ0KTtcbiAgfVxuICBmdW5jdGlvbiBmaXJlU3ZlbHRlRHJhZ0VuZEV2ZW50KCkge1xuICAgIGNhbGxFdmVudChcIm5lb2RyYWc6ZW5kXCIsIG9uRHJhZ0VuZCk7XG4gIH1cbiAgZnVuY3Rpb24gZmlyZVN2ZWx0ZURyYWdFdmVudCgpIHtcbiAgICBjYWxsRXZlbnQoXCJuZW9kcmFnXCIsIG9uRHJhZyk7XG4gIH1cbiAgY29uc3QgbGlzdGVuID0gYWRkRXZlbnRMaXN0ZW5lcjtcbiAgbGlzdGVuKFwicG9pbnRlcmRvd25cIiwgZHJhZ1N0YXJ0LCBmYWxzZSk7XG4gIGxpc3RlbihcInBvaW50ZXJ1cFwiLCBkcmFnRW5kLCBmYWxzZSk7XG4gIGxpc3RlbihcInBvaW50ZXJtb3ZlXCIsIGRyYWcsIGZhbHNlKTtcbiAgc2V0U3R5bGUobm9kZSwgXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpO1xuICBjb25zdCBjYWxjdWxhdGVJbnZlcnNlU2NhbGUgPSAoKSA9PiB7XG4gICAgbGV0IGludmVyc2VTY2FsZSA9IG5vZGUub2Zmc2V0V2lkdGggLyBub2RlUmVjdC53aWR0aDtcbiAgICBpZiAoaXNOYU4oaW52ZXJzZVNjYWxlKSlcbiAgICAgIGludmVyc2VTY2FsZSA9IDE7XG4gICAgcmV0dXJuIGludmVyc2VTY2FsZTtcbiAgfTtcbiAgZnVuY3Rpb24gZHJhZ1N0YXJ0KGUpIHtcbiAgICBpZiAoZGlzYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGUuYnV0dG9uID09PSAyKVxuICAgICAgcmV0dXJuO1xuICAgIGFjdGl2ZVBvaW50ZXJzLmFkZChlLnBvaW50ZXJJZCk7XG4gICAgaWYgKGlnbm9yZU11bHRpdG91Y2ggJiYgYWN0aXZlUG9pbnRlcnMuc2l6ZSA+IDEpXG4gICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChyZWNvbXB1dGVCb3VuZHMuZHJhZ1N0YXJ0KVxuICAgICAgY29tcHV0ZWRCb3VuZHMgPSBjb21wdXRlQm91bmRSZWN0KGJvdW5kcywgbm9kZSk7XG4gICAgaWYgKGlzU3RyaW5nKGhhbmRsZSkgJiYgaXNTdHJpbmcoY2FuY2VsKSAmJiBoYW5kbGUgPT09IGNhbmNlbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBoYW5kbGVgIHNlbGVjdG9yIGNhbid0IGJlIHNhbWUgYXMgYGNhbmNlbGAgc2VsZWN0b3JcIik7XG4gICAgbm9kZUNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzKTtcbiAgICBkcmFnRWxzID0gZ2V0SGFuZGxlRWxzKGhhbmRsZSwgbm9kZSk7XG4gICAgY2FuY2VsRWxzID0gZ2V0Q2FuY2VsRWxlbWVudHMoY2FuY2VsLCBub2RlKTtcbiAgICBjYW5Nb3ZlSW5YID0gLyhib3RofHgpLy50ZXN0KGF4aXMpO1xuICAgIGNhbk1vdmVJblkgPSAvKGJvdGh8eSkvLnRlc3QoYXhpcyk7XG4gICAgaWYgKGNhbmNlbEVsZW1lbnRDb250YWlucyhjYW5jZWxFbHMsIGRyYWdFbHMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkVsZW1lbnQgYmVpbmcgZHJhZ2dlZCBjYW4ndCBiZSBhIGNoaWxkIG9mIHRoZSBlbGVtZW50IG9uIHdoaWNoIGBjYW5jZWxgIGlzIGFwcGxpZWRcIlxuICAgICAgKTtcbiAgICBjb25zdCBldmVudFRhcmdldCA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gICAgaWYgKGRyYWdFbHMuc29tZSgoZWwpID0+IGVsLmNvbnRhaW5zKGV2ZW50VGFyZ2V0KSB8fCBlbC5zaGFkb3dSb290Py5jb250YWlucyhldmVudFRhcmdldCkpICYmICFjYW5jZWxFbGVtZW50Q29udGFpbnMoY2FuY2VsRWxzLCBbZXZlbnRUYXJnZXRdKSkge1xuICAgICAgY3VycmVudGx5RHJhZ2dlZEVsID0gZHJhZ0Vscy5sZW5ndGggPT09IDEgPyBub2RlIDogZHJhZ0Vscy5maW5kKChlbCkgPT4gZWwuY29udGFpbnMoZXZlbnRUYXJnZXQpKTtcbiAgICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm47XG4gICAgbm9kZVJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChhcHBseVVzZXJTZWxlY3RIYWNrKSB7XG4gICAgICBib2R5T3JpZ2luYWxVc2VyU2VsZWN0VmFsID0gYm9keVN0eWxlLnVzZXJTZWxlY3Q7XG4gICAgICBib2R5U3R5bGUudXNlclNlbGVjdCA9IFwibm9uZVwiO1xuICAgIH1cbiAgICBmaXJlU3ZlbHRlRHJhZ1N0YXJ0RXZlbnQoKTtcbiAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XG4gICAgY29uc3QgaW52ZXJzZVNjYWxlID0gY2FsY3VsYXRlSW52ZXJzZVNjYWxlKCk7XG4gICAgaWYgKGNhbk1vdmVJblgpXG4gICAgICBpbml0aWFsWCA9IGNsaWVudFggLSB4T2Zmc2V0IC8gaW52ZXJzZVNjYWxlO1xuICAgIGlmIChjYW5Nb3ZlSW5ZKVxuICAgICAgaW5pdGlhbFkgPSBjbGllbnRZIC0geU9mZnNldCAvIGludmVyc2VTY2FsZTtcbiAgICBpZiAoY29tcHV0ZWRCb3VuZHMpIHtcbiAgICAgIGNsaWVudFRvTm9kZU9mZnNldFggPSBjbGllbnRYIC0gbm9kZVJlY3QubGVmdDtcbiAgICAgIGNsaWVudFRvTm9kZU9mZnNldFkgPSBjbGllbnRZIC0gbm9kZVJlY3QudG9wO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkcmFnRW5kKGUpIHtcbiAgICBhY3RpdmVQb2ludGVycy5kZWxldGUoZS5wb2ludGVySWQpO1xuICAgIGlmICghYWN0aXZlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChyZWNvbXB1dGVCb3VuZHMuZHJhZ0VuZClcbiAgICAgIGNvbXB1dGVkQm91bmRzID0gY29tcHV0ZUJvdW5kUmVjdChib3VuZHMsIG5vZGUpO1xuICAgIG5vZGVDbGFzc0xpc3QucmVtb3ZlKGRlZmF1bHRDbGFzc0RyYWdnaW5nKTtcbiAgICBub2RlQ2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NEcmFnZ2VkKTtcbiAgICBpZiAoYXBwbHlVc2VyU2VsZWN0SGFjaylcbiAgICAgIGJvZHlTdHlsZS51c2VyU2VsZWN0ID0gYm9keU9yaWdpbmFsVXNlclNlbGVjdFZhbDtcbiAgICBmaXJlU3ZlbHRlRHJhZ0VuZEV2ZW50KCk7XG4gICAgaWYgKGNhbk1vdmVJblgpXG4gICAgICBpbml0aWFsWCA9IHRyYW5zbGF0ZVg7XG4gICAgaWYgKGNhbk1vdmVJblkpXG4gICAgICBpbml0aWFsWSA9IHRyYW5zbGF0ZVk7XG4gICAgYWN0aXZlID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZHJhZyhlKSB7XG4gICAgaWYgKCFhY3RpdmUgfHwgaWdub3JlTXVsdGl0b3VjaCAmJiBhY3RpdmVQb2ludGVycy5zaXplID4gMSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAocmVjb21wdXRlQm91bmRzLmRyYWcpXG4gICAgICBjb21wdXRlZEJvdW5kcyA9IGNvbXB1dGVCb3VuZFJlY3QoYm91bmRzLCBub2RlKTtcbiAgICBub2RlQ2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NEcmFnZ2luZyk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG5vZGVSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZmluYWxYID0gZS5jbGllbnRYLCBmaW5hbFkgPSBlLmNsaWVudFk7XG4gICAgY29uc3QgaW52ZXJzZVNjYWxlID0gY2FsY3VsYXRlSW52ZXJzZVNjYWxlKCk7XG4gICAgaWYgKGNvbXB1dGVkQm91bmRzKSB7XG4gICAgICBjb25zdCB2aXJ0dWFsQ2xpZW50Qm91bmRzID0ge1xuICAgICAgICBsZWZ0OiBjb21wdXRlZEJvdW5kcy5sZWZ0ICsgY2xpZW50VG9Ob2RlT2Zmc2V0WCxcbiAgICAgICAgdG9wOiBjb21wdXRlZEJvdW5kcy50b3AgKyBjbGllbnRUb05vZGVPZmZzZXRZLFxuICAgICAgICByaWdodDogY29tcHV0ZWRCb3VuZHMucmlnaHQgKyBjbGllbnRUb05vZGVPZmZzZXRYIC0gbm9kZVJlY3Qud2lkdGgsXG4gICAgICAgIGJvdHRvbTogY29tcHV0ZWRCb3VuZHMuYm90dG9tICsgY2xpZW50VG9Ob2RlT2Zmc2V0WSAtIG5vZGVSZWN0LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGZpbmFsWCA9IGNsYW1wKGZpbmFsWCwgdmlydHVhbENsaWVudEJvdW5kcy5sZWZ0LCB2aXJ0dWFsQ2xpZW50Qm91bmRzLnJpZ2h0KTtcbiAgICAgIGZpbmFsWSA9IGNsYW1wKGZpbmFsWSwgdmlydHVhbENsaWVudEJvdW5kcy50b3AsIHZpcnR1YWxDbGllbnRCb3VuZHMuYm90dG9tKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ3JpZCkpIHtcbiAgICAgIGxldCBbeFNuYXAsIHlTbmFwXSA9IGdyaWQ7XG4gICAgICBpZiAoaXNOYU4oK3hTbmFwKSB8fCB4U25hcCA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIjFzdCBhcmd1bWVudCBvZiBgZ3JpZGAgbXVzdCBiZSBhIHZhbGlkIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgIGlmIChpc05hTigreVNuYXApIHx8IHlTbmFwIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiMm5kIGFyZ3VtZW50IG9mIGBncmlkYCBtdXN0IGJlIGEgdmFsaWQgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgbGV0IGRlbHRhWCA9IGZpbmFsWCAtIGluaXRpYWxYLCBkZWx0YVkgPSBmaW5hbFkgLSBpbml0aWFsWTtcbiAgICAgIFtkZWx0YVgsIGRlbHRhWV0gPSBzbmFwVG9HcmlkKFt4U25hcCAvIGludmVyc2VTY2FsZSwgeVNuYXAgLyBpbnZlcnNlU2NhbGVdLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICBmaW5hbFggPSBpbml0aWFsWCArIGRlbHRhWDtcbiAgICAgIGZpbmFsWSA9IGluaXRpYWxZICsgZGVsdGFZO1xuICAgIH1cbiAgICBpZiAoY2FuTW92ZUluWClcbiAgICAgIHRyYW5zbGF0ZVggPSBNYXRoLnJvdW5kKChmaW5hbFggLSBpbml0aWFsWCkgKiBpbnZlcnNlU2NhbGUpO1xuICAgIGlmIChjYW5Nb3ZlSW5ZKVxuICAgICAgdHJhbnNsYXRlWSA9IE1hdGgucm91bmQoKGZpbmFsWSAtIGluaXRpYWxZKSAqIGludmVyc2VTY2FsZSk7XG4gICAgeE9mZnNldCA9IHRyYW5zbGF0ZVg7XG4gICAgeU9mZnNldCA9IHRyYW5zbGF0ZVk7XG4gICAgZmlyZVN2ZWx0ZURyYWdFdmVudCgpO1xuICAgIHNldFRyYW5zbGF0ZSgpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgY29uc3QgdW5saXN0ZW4gPSByZW1vdmVFdmVudExpc3RlbmVyO1xuICAgICAgdW5saXN0ZW4oXCJwb2ludGVyZG93blwiLCBkcmFnU3RhcnQsIGZhbHNlKTtcbiAgICAgIHVubGlzdGVuKFwicG9pbnRlcnVwXCIsIGRyYWdFbmQsIGZhbHNlKTtcbiAgICAgIHVubGlzdGVuKFwicG9pbnRlcm1vdmVcIiwgZHJhZywgZmFsc2UpO1xuICAgIH0sXG4gICAgdXBkYXRlOiAob3B0aW9uczIpID0+IHtcbiAgICAgIGF4aXMgPSBvcHRpb25zMi5heGlzIHx8IFwiYm90aFwiO1xuICAgICAgZGlzYWJsZWQgPSBvcHRpb25zMi5kaXNhYmxlZCA/PyBmYWxzZTtcbiAgICAgIGlnbm9yZU11bHRpdG91Y2ggPSBvcHRpb25zMi5pZ25vcmVNdWx0aXRvdWNoID8/IGZhbHNlO1xuICAgICAgaGFuZGxlID0gb3B0aW9uczIuaGFuZGxlO1xuICAgICAgYm91bmRzID0gb3B0aW9uczIuYm91bmRzO1xuICAgICAgcmVjb21wdXRlQm91bmRzID0gb3B0aW9uczIucmVjb21wdXRlQm91bmRzID8/IERFRkFVTFRfUkVDT01QVVRFX0JPVU5EUztcbiAgICAgIGNhbmNlbCA9IG9wdGlvbnMyLmNhbmNlbDtcbiAgICAgIGFwcGx5VXNlclNlbGVjdEhhY2sgPSBvcHRpb25zMi5hcHBseVVzZXJTZWxlY3RIYWNrID8/IHRydWU7XG4gICAgICBncmlkID0gb3B0aW9uczIuZ3JpZDtcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IG9wdGlvbnMyLmdwdUFjY2VsZXJhdGlvbiA/PyB0cnVlO1xuICAgICAgbGVnYWN5VHJhbnNsYXRlID0gb3B0aW9uczIubGVnYWN5VHJhbnNsYXRlID8/IHRydWU7XG4gICAgICB0cmFuc2Zvcm0gPSBvcHRpb25zMi50cmFuc2Zvcm07XG4gICAgICBjb25zdCBkcmFnZ2VkID0gbm9kZUNsYXNzTGlzdC5jb250YWlucyhkZWZhdWx0Q2xhc3NEcmFnZ2VkKTtcbiAgICAgIG5vZGVDbGFzc0xpc3QucmVtb3ZlKGRlZmF1bHRDbGFzcywgZGVmYXVsdENsYXNzRHJhZ2dlZCk7XG4gICAgICBkZWZhdWx0Q2xhc3MgPSBvcHRpb25zMi5kZWZhdWx0Q2xhc3MgPz8gXCJuZW9kcmFnXCI7XG4gICAgICBkZWZhdWx0Q2xhc3NEcmFnZ2luZyA9IG9wdGlvbnMyLmRlZmF1bHRDbGFzc0RyYWdnaW5nID8/IFwibmVvZHJhZy1kcmFnZ2luZ1wiO1xuICAgICAgZGVmYXVsdENsYXNzRHJhZ2dlZCA9IG9wdGlvbnMyLmRlZmF1bHRDbGFzc0RyYWdnZWQgPz8gXCJuZW9kcmFnLWRyYWdnZWRcIjtcbiAgICAgIG5vZGVDbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzcyk7XG4gICAgICBpZiAoZHJhZ2dlZClcbiAgICAgICAgbm9kZUNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzRHJhZ2dlZCk7XG4gICAgICBpZiAoaXNDb250cm9sbGVkKSB7XG4gICAgICAgIHhPZmZzZXQgPSB0cmFuc2xhdGVYID0gb3B0aW9uczIucG9zaXRpb24/LnggPz8gdHJhbnNsYXRlWDtcbiAgICAgICAgeU9mZnNldCA9IHRyYW5zbGF0ZVkgPSBvcHRpb25zMi5wb3NpdGlvbj8ueSA/PyB0cmFuc2xhdGVZO1xuICAgICAgICBzZXRUcmFuc2xhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xudmFyIGNsYW1wID0gKHZhbCwgbWluLCBtYXgpID0+IE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbnZhciBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG52YXIgc25hcFRvR3JpZCA9IChbeFNuYXAsIHlTbmFwXSwgcGVuZGluZ1gsIHBlbmRpbmdZKSA9PiB7XG4gIGNvbnN0IGNhbGMgPSAodmFsLCBzbmFwKSA9PiBzbmFwID09PSAwID8gMCA6IE1hdGguY2VpbCh2YWwgLyBzbmFwKSAqIHNuYXA7XG4gIGNvbnN0IHggPSBjYWxjKHBlbmRpbmdYLCB4U25hcCk7XG4gIGNvbnN0IHkgPSBjYWxjKHBlbmRpbmdZLCB5U25hcCk7XG4gIHJldHVybiBbeCwgeV07XG59O1xuZnVuY3Rpb24gZ2V0SGFuZGxlRWxzKGhhbmRsZSwgbm9kZSkge1xuICBpZiAoIWhhbmRsZSlcbiAgICByZXR1cm4gW25vZGVdO1xuICBpZiAoaXNIVE1MRWxlbWVudChoYW5kbGUpKVxuICAgIHJldHVybiBbaGFuZGxlXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlKSlcbiAgICByZXR1cm4gaGFuZGxlO1xuICBjb25zdCBoYW5kbGVFbHMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoaGFuZGxlKTtcbiAgaWYgKGhhbmRsZUVscyA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlNlbGVjdG9yIHBhc3NlZCBmb3IgYGhhbmRsZWAgb3B0aW9uIHNob3VsZCBiZSBjaGlsZCBvZiB0aGUgZWxlbWVudCBvbiB3aGljaCB0aGUgYWN0aW9uIGlzIGFwcGxpZWRcIlxuICAgICk7XG4gIHJldHVybiBBcnJheS5mcm9tKGhhbmRsZUVscy52YWx1ZXMoKSk7XG59XG5mdW5jdGlvbiBnZXRDYW5jZWxFbGVtZW50cyhjYW5jZWwsIG5vZGUpIHtcbiAgaWYgKCFjYW5jZWwpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAoaXNIVE1MRWxlbWVudChjYW5jZWwpKVxuICAgIHJldHVybiBbY2FuY2VsXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2FuY2VsKSlcbiAgICByZXR1cm4gY2FuY2VsO1xuICBjb25zdCBjYW5jZWxFbHMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuY2VsKTtcbiAgaWYgKGNhbmNlbEVscyA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlNlbGVjdG9yIHBhc3NlZCBmb3IgYGNhbmNlbGAgb3B0aW9uIHNob3VsZCBiZSBjaGlsZCBvZiB0aGUgZWxlbWVudCBvbiB3aGljaCB0aGUgYWN0aW9uIGlzIGFwcGxpZWRcIlxuICAgICk7XG4gIHJldHVybiBBcnJheS5mcm9tKGNhbmNlbEVscy52YWx1ZXMoKSk7XG59XG52YXIgY2FuY2VsRWxlbWVudENvbnRhaW5zID0gKGNhbmNlbEVsZW1lbnRzLCBkcmFnRWxlbWVudHMpID0+IGNhbmNlbEVsZW1lbnRzLnNvbWUoKGNhbmNlbEVsKSA9PiBkcmFnRWxlbWVudHMuc29tZSgoZWwpID0+IGNhbmNlbEVsLmNvbnRhaW5zKGVsKSkpO1xuZnVuY3Rpb24gY29tcHV0ZUJvdW5kUmVjdChib3VuZHMsIHJvb3ROb2RlKSB7XG4gIGlmIChib3VuZHMgPT09IHZvaWQgMClcbiAgICByZXR1cm47XG4gIGlmIChpc0hUTUxFbGVtZW50KGJvdW5kcykpXG4gICAgcmV0dXJuIGJvdW5kcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgaWYgKHR5cGVvZiBib3VuZHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCB7IHRvcCA9IDAsIGxlZnQgPSAwLCByaWdodCA9IDAsIGJvdHRvbSA9IDAgfSA9IGJvdW5kcztcbiAgICBjb25zdCBjb21wdXRlZFJpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLSByaWdodDtcbiAgICBjb25zdCBjb21wdXRlZEJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGJvdHRvbTtcbiAgICByZXR1cm4geyB0b3AsIHJpZ2h0OiBjb21wdXRlZFJpZ2h0LCBib3R0b206IGNvbXB1dGVkQm90dG9tLCBsZWZ0IH07XG4gIH1cbiAgaWYgKGJvdW5kcyA9PT0gXCJwYXJlbnRcIilcbiAgICByZXR1cm4gcm9vdE5vZGUucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYm91bmRzKTtcbiAgaWYgKG5vZGUgPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlbGVjdG9yIHByb3ZpZGVkIGZvciBib3VuZCBkb2Vzbid0IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQuXCIpO1xuICByZXR1cm4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cbnZhciBzZXRTdHlsZSA9IChlbCwgc3R5bGUsIHZhbHVlKSA9PiBlbC5zdHlsZS5zZXRQcm9wZXJ0eShzdHlsZSwgdmFsdWUpO1xudmFyIGlzSFRNTEVsZW1lbnQgPSAob2JqKSA9PiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbmZ1bmN0aW9uIHVud3JhcEhhbmRsZUNhbmNlbCh2YWwpIHtcbiAgaWYgKHZhbCA9PSB2b2lkIDAgfHwgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB2YWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudClcbiAgICByZXR1cm4gdmFsO1xuICBpZiAoXCJjdXJyZW50XCIgaW4gdmFsKVxuICAgIHJldHVybiB2YWwuY3VycmVudDtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiB2YWwubWFwKCh2KSA9PiB2IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyB2IDogdi5jdXJyZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlRHJhZ2dhYmxlKG5vZGVSZWYsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB1cGRhdGVSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgW2lzRHJhZ2dpbmcsIHNldElzRHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZHJhZ1N0YXRlLCBzZXREcmFnU3RhdGVdID0gdXNlU3RhdGUoKTtcbiAgbGV0IHsgb25EcmFnU3RhcnQsIG9uRHJhZywgb25EcmFnRW5kLCBoYW5kbGUsIGNhbmNlbCB9ID0gb3B0aW9ucztcbiAgbGV0IG5ld0hhbmRsZSA9IHVud3JhcEhhbmRsZUNhbmNlbChoYW5kbGUpO1xuICBsZXQgbmV3Q2FuY2VsID0gdW53cmFwSGFuZGxlQ2FuY2VsKGNhbmNlbCk7XG4gIGZ1bmN0aW9uIGNhbGxFdmVudChhcmcsIGNiKSB7XG4gICAgc2V0RHJhZ1N0YXRlKGFyZyk7XG4gICAgY2I/LihhcmcpO1xuICB9XG4gIGZ1bmN0aW9uIGN1c3RvbU9uRHJhZ1N0YXJ0KGFyZykge1xuICAgIHNldElzRHJhZ2dpbmcodHJ1ZSk7XG4gICAgY2FsbEV2ZW50KGFyZywgb25EcmFnU3RhcnQpO1xuICB9XG4gIGZ1bmN0aW9uIGN1c3RvbU9uRHJhZyhhcmcpIHtcbiAgICBjYWxsRXZlbnQoYXJnLCBvbkRyYWcpO1xuICB9XG4gIGZ1bmN0aW9uIGN1c3RvbU9uRHJhZ0VuZChhcmcpIHtcbiAgICBzZXRJc0RyYWdnaW5nKGZhbHNlKTtcbiAgICBjYWxsRXZlbnQoYXJnLCBvbkRyYWdFbmQpO1xuICB9XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVSZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgKHsgb25EcmFnU3RhcnQsIG9uRHJhZywgb25EcmFnRW5kIH0gPSBvcHRpb25zKTtcbiAgICBjb25zdCB7IHVwZGF0ZSwgZGVzdHJveSB9ID0gZHJhZ2dhYmxlKG5vZGUsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoYW5kbGU6IG5ld0hhbmRsZSxcbiAgICAgIGNhbmNlbDogbmV3Q2FuY2VsLFxuICAgICAgb25EcmFnU3RhcnQ6IGN1c3RvbU9uRHJhZ1N0YXJ0LFxuICAgICAgb25EcmFnOiBjdXN0b21PbkRyYWcsXG4gICAgICBvbkRyYWdFbmQ6IGN1c3RvbU9uRHJhZ0VuZFxuICAgIH0pO1xuICAgIHVwZGF0ZVJlZi5jdXJyZW50ID0gdXBkYXRlO1xuICAgIHJldHVybiBkZXN0cm95O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdXBkYXRlUmVmLmN1cnJlbnQ/Lih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGFuZGxlOiB1bndyYXBIYW5kbGVDYW5jZWwoaGFuZGxlKSxcbiAgICAgIGNhbmNlbDogdW53cmFwSGFuZGxlQ2FuY2VsKGNhbmNlbCksXG4gICAgICBvbkRyYWdTdGFydDogY3VzdG9tT25EcmFnU3RhcnQsXG4gICAgICBvbkRyYWc6IGN1c3RvbU9uRHJhZyxcbiAgICAgIG9uRHJhZ0VuZDogY3VzdG9tT25EcmFnRW5kXG4gICAgfSk7XG4gIH0sIFtvcHRpb25zXSk7XG4gIHJldHVybiB7IGlzRHJhZ2dpbmcsIGRyYWdTdGF0ZSB9O1xufVxuXG5leHBvcnQgeyB1c2VEcmFnZ2FibGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@neodrag/react/dist/index.js\n");

/***/ })

};
;